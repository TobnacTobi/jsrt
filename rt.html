<!DOCTYPE html>
<html>
<head><title>Javascript RT</title></head>

<body>
<canvas id="framebuffer" width="800" height="600"></canvas>
<script type="text/javascript">
var ctx;
var pixels;
var screen_width = 520;
var screen_height = 400;

function init() {
    ctx = document.getElementById('framebuffer').getContext('2d');
    pixels = ctx.createImageData(screen_width, screen_height);
};

function draw() {
    computeScene();
    ctx.putImageData(pixels, 0, 0);
};

function computeScene() {
    var scene = new Scene();

    var sphere1 = scene.addObject(new Obj("Sphere 1",new Sphere()));
    var sphere2 = scene.addObject(new Obj("Sphere 2",new Sphere()));
    var light1 = scene.addLight(new Obj("Light 1",new Light()));
    var light2 = scene.addLight(new Obj("Light 2",new Light()));
    var light3 = scene.addLight(new Obj("Light 3",new Light()));

    sphere1.o.center.x -= .8
    sphere1.o.radius = 0.5;
   
    sphere2.o.center.x += .8;
    sphere2.o.radius = 0.5;

    light1.o.center.set(4,-1,-2);
    light2.o.center.set(-1,-1,-2);
    light3.o.center.set(1,-6,-2);

    light1.color.r = .5;
    light1.color.g = .5;
    light1.color.b = .5;

    light2.color.r = .3;
    light2.color.g = .3;
    light2.color.b = .3;

    light3.color.r = .4;
    light3.color.g = .4;
    light3.color.b = .4;

    sphere1.color.r = 1;
    sphere1.color.g = .3;
    sphere1.color.b = .3;
    sphere1.specularity = .5;

    sphere2.color.r = .3;
    sphere2.color.g = 1;
    sphere2.color.b = .3;

    scene.traceScene();
}

// Vector implementation

function Vector(x,y,z) {
    if (arguments.length == 0) {
        x = y = z = 0;
    }
    this.x = x;
    this.y = y;
    this.z = z;

    // Set x, y, z
    this.set = function(x,y,z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    // Return true if the two vectors are equal
    this.equal = function(v2) {
        var v1 = this;
        return v1.x == v2.x && v1.y == v2.y && v1.z == v2.z;
    }

    // Vectors addition
    this.add = function(v2) {
        var v1 = this;
        return new Vector(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z);
    }

    // Vectors subtraction
    this.sub = function(v2) {
        var v1 = this;
        return new Vector(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z);
    }

    // Vectors multiplication
    this.mul = function(v2) {
        var v1 = this;
        return new Vector(v1.x*v2.x, v1.y*v2.y, v1.z*v2.z);
    }

    // Vectors division
    this.div = function(v2) {
        var v1 = this;
        return new Vector(
            v1.x/ (v2.x == 0 ? 1 : v2.x),
            v1.y/ (v2.y == 0 ? 1 : v2.y),
            v1.z/ (v2.z == 0 ? 1 : v2.z));
    }

    // Vector magnitude
    this.magnitude = function() {
        return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
    }

    // Vector dot (scalar) product
    this.dot = function(v2) {
        var v1 = this;
        return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;
    }

    // Vector cross (vectorial) product
    this.cross = function(v2) {
        var v1 = this;
        return new Vector(
            (v1.y*v2.z)-(v1.z*v2.y),
            (v1.z*v2.x)-(v1.x*v2.z),
            (v1.x*v2.y)-(v1.y*v2.x));
    }
    
    // Vector normalization (modify the vector so that that it has
    // magnitude 1 but with the same orientation as the original vector).
    this.normalize = function() {
        var m = this.magnitude();

        if (m == 0) m = 1;
        this.x /= m;
        this.y /= m;
        this.z /= m;
        return this;
    }
}

// Ray implementation

function Ray() {
    this.origin = new Vector();
    this.direction = new Vector();
}

// Sphere implementation

function Sphere() {
    this.type = "sphere";
    this.center = new Vector();
    this.radius = 1.0;

    /* Normal on a point of the sphere, normalized. */
    this.normalToPoint = function(p) {
        return p.sub(this.center).normalize();
    }

    /* Intersect a ray with this sphere. Returns an object
       with two fields: 'type' and 'dist'.

       Type can be:

       0: no intersection
       1: internal intersection (the ray origin is inside the sphere)
       2: external intersection (the ray origin is outside the sphere)

       The distance is simply the distance between the ray origin and
       the intersection point.

       NOTE: This function needs ray.direction to be normalized. */
    this.intersect = function(ray) {
        var x, y, z, distance = +Infinity;

        /* set x,y,z to the sphere center minus the ray origin. */
        x = this.center.x - ray.origin.x;
        y = this.center.y - ray.origin.y;
        z = this.center.z - ray.origin.z;
        /* compute x,y,z dot product with itself. */
        var xyz_dot = (x*x)+(y*y)+(z*z);
        /* compute dot product between x,y,z and ray direction. */
        var b = (x*ray.direction.x)+(y*ray.direction.y)+(z*ray.direction.z);

        /* We can now compute the discriminant and check for intersections. */
        var disc = b*b - xyz_dot + this.radius*this.radius;
        var type = 0;

        if (disc > 0) {
            var d = Math.sqrt(disc);
            var root1 = b-d;
            var root2 = b+d;

            if (root2 > 0) {
                if (root1 < 0) {
                    if (root2 < distance) { distance = root2; type = -1; }
                } else {
                    if (root1 < distance) { distance = root1; type = 1; }
                }
            }
        }
        return {type: type, dist: distance};
    }
}

// Light

function Light() {
    this.type = "light";
    this.center = new Vector();
}

// Generic scene object implementation

function Obj(name,o) {
    this.name = name;
    this.o = o;
    this.color = {r: 1, g: 1, b: 1};
    this.specularity = 0;
}

// Scene object

function Scene() {
    this.objects = [];
    this.lights = [];

    this.addObject = function(o) {
        this.objects.push(o);
        return o;
    }

    this.addLight = function(o) {
        this.lights.push(o);
        return o;
    }

    this.traceRay = function (ray) {
        var obj = null;
        var color = {r: 0, g: 0, b: 0}
        var distance = +Infinity;

        for (var j = 0; j < this.objects.length; j++) {
            var test_obj = this.objects[j];
            var res = test_obj.o.intersect(ray);
            if (res.type) {
                if (obj == null || res.dist < distance) {
                    obj = test_obj;
                    distance = res.dist;
                }
            }
        }
        /* Determine the color if we hit sometihng */
        if (obj) {
            /* We have the distance, so we can compute the intersection
               point simply as: origin + (direction * distance) */
            var point = new Vector(ray.direction.x,
                                   ray.direction.y,
                                   ray.direction.z);
            point.x = ray.origin.x + point.x*distance;
            point.y = ray.origin.y + point.y*distance;
            point.z = ray.origin.z + point.z*distance;
            /* Now get the normal to the intersection point of the object */
            var normal = obj.o.normalToPoint(point);
            for (j = 0; j < this.lights.length; j++) {
                var light = this.lights[j];
                /* Compute the vector that looks from the intersection
                   point to the light */
                var l = light.o.center.sub(point).normalize();
                /* Now the dot product between the normal and the point
                   towards the light is the cosine between the angle
                   formed by the vectors, that is, our brightness. */
                var cosine = normal.dot(l);
                if (cosine < 0) cosine = 0;
                color.r += cosine * obj.color.r * light.color.r;
                color.g += cosine * obj.color.g * light.color.g;
                color.b += cosine * obj.color.b * light.color.b;
                /* Add phong shading */
                if (obj.specularity > 0) {
                    var Vr = l.sub(normal.mul(new Vector(cosine*2,cosine*2,cosine*2)));
                    var cosSigma = ray.direction.dot(Vr);
                    if (cosSigma > 0) {
                        var specularity = obj.specularity;
                        color.r += obj.color.r * specularity * Math.pow(cosSigma,64);
                        color.g += obj.color.g * specularity * Math.pow(cosSigma,64);
                        color.b += obj.color.b * specularity * Math.pow(cosSigma,64);
                    }
                }
            }
            if (color.r > 1) color.r = 1;
            if (color.g > 1) color.g = 1;
            if (color.b > 1) color.b = 1;
        }
        return {obj: obj, color: color}
    }

    this.traceScene = function () {
        var pov = new Vector(0,0,-4);
        var ray = new Ray();

        ray.origin = pov
        for (var x = 0; x < screen_width; x++) {
            for (var y = 0; y < screen_height; y++) {
                ray.direction.set((x-screen_width/2)/100,
                                  (y-screen_height/2)/100,
                                  4);
                ray.direction.normalize();
                var trace = this.traceRay(ray);
                var offset = x*4+y*4*screen_width;

                pixels.data[offset+3] = 255;
                pixels.data[offset+0] = trace.color.r*255;
                pixels.data[offset+1] = trace.color.g*255;
                pixels.data[offset+2] = trace.color.b*255;
            }
        }
    }
}

init();
for (var c = 0; c < 1; c++) {
    var start = new Date().getTime();
    draw();
    console.debug("elapsed: "+((new Date().getTime())-start));
}

</script>
</body>
</html>
